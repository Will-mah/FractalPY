import pylab
import argparse
import collections
import inspect
import functools
from itertools import takewhile
import time
import multiprocessing

# Define a simple structure to represent a point in 2D space.
Point = collections.namedtuple("Point", ["x", "y"])

def pair_reader(dtype):
    """Create a function to read two values separated by 'x' and convert them into a Point namedtuple.
    
    Parameters:
        dtype (type): The data type to which the input strings will be converted.
    
    Returns:
        function: A function that takes a string input and returns a Point namedtuple.
    """
    return lambda data: Point(*map(dtype, data.lower().split("x")))

# Configuration defaults for fractal generation.
DEFAULTS = {
    'size': "1920x1080",      # Size of the generated fractal image.
    'depth': "69",         # Maximum number of iterations (depth) for the fractal calculation.
    'zoom': "10",            # Zoom level for the fractal image.
    'center': "0x0",        # Center point for the fractal image.
    'colormap': "jet"      # Color mapping for the fractal image visualization.
}

def repeater(func):
    """Decorator to transform a function into an infinite generator, 
    repeatedly applying the function to its own output.
    
    Parameters:
        func (function): The function to be transformed.
    
    Returns:
        generator: An infinite generator yielding the results of repeatedly applying 'func'.
    """
    @functools.wraps(func)
    def wrapper(n):
        val = n
        while True:
            yield val
            val = func(val)
    return wrapper

def amount(generator, limit=float("inf")):
    """Determine the number of items generated by a generator, up to a specified limit.
    
    Parameters:
        generator (iterator): The generator to consume.
        limit (int, optional): The maximum number of items to consume from the generator.
    
    Returns:
        int: The number of items generated, up to 'limit'.
    """
    size = 0
    for _ in generator:
        size += 1
        if size >= limit:
            break
    return size


def in_circle(radius):  
  return lambda z: z.real ** 2 + z.imag ** 2 < radius ** 2


def fractal_eta(z, func, limit, radius=2): 
  return amount(takewhile(in_circle(radius), repeater(func)(z)), limit)


def cqp(c):
  
  return lambda z: z ** 2 + c


def get_model(model, depth, c):
 
  if model == "julia":
    func = cqp(c)
    return lambda x, y: fractal_eta(x + y * 1j, func, depth)
  if model == "mandelbrot":
    return lambda x, y: fractal_eta(0, cqp(x + y * 1j), depth)
  raise ValueError("Fractal not found")


def generate_fractal(model, c=None, size=pair_reader(int)(DEFAULTS['size']),
                     depth=int(DEFAULTS['depth']), zoom=float(DEFAULTS['zoom']),
                     center=pair_reader(float)(DEFAULTS['center'])):
    """
    Generate a fractal image using the given model and parameters.
    
    Parameters:
        model: The fractal model to use.
        c: The complex parameter for the fractal (default is None).
        size: The size of the fractal image as a tuple of (width, height).
        depth: The maximum iterations for fractal generation.
        zoom: The zoom level for the fractal generation.
        center: The center point of the fractal image as a Point namedtuple.
    
    Returns:
        2D Numpy Array: A numpy array representing the fractal image.
    """
    num_procs = multiprocessing.cpu_count()
    print('CPU Count:', num_procs)
    start = time.time()

    # Create a pool of workers, one for each row
    pool = multiprocessing.Pool(num_procs)
    procs = [pool.apply_async(generate_row,
                            [model, c, size, depth, zoom, center, row])
           for row in range(size[1])]

    # Generates the intensities for each pixel
    img = pylab.array([row_proc.get() for row_proc in procs])

    print('Time taken:', time.time() - start)
    return img



def generate_row(model, c, size, depth, zoom, center, row):
 
  func = get_model(model, depth, c)
  width, height = size
  cx, cy = center
  side = max(width, height)
  sidem1 = side - 1
  deltax = (side - width) / 2 # Centralize
  deltay = (side - height) / 2
  y = (2 * (height - row + deltay) / sidem1 - 1) / zoom + cy
  return [func((2 * (col + deltax) / sidem1 - 1) / zoom + cx, y)
          for col in range(width)]


def img2output(img, cmap=DEFAULTS['colormap'], output=None, show=False):
    """
    Save or display an image using the specified colormap.
    
    Parameters:
        img: The image to be saved or displayed.
        cmap: The colormap to be used for the image.
        output: The file path to save the image to. If None, the image is not saved.
        show: A boolean indicating whether to display the image or not.
    """
    if output:
        pylab.imsave(output, img, cmap=cmap)
    if show:
        pylab.imshow(img, cmap=cmap)
        pylab.show()



def call_kw(func, kwargs):
    
    sig = inspect.signature(func)
    kwfiltered = {k: v for k, v in kwargs.items() if k in sig.parameters}
    return func(**kwfiltered)


def exec_command(kwargs):
  
  kwargs["img"] = call_kw(generate_fractal, kwargs)
  call_kw(img2output, kwargs)


def cli_parse_args(args=None, namespace=None):
    """
    Parse command-line arguments for the fractal generator.

    Parameters:
        args: List of strings to parse. The default is taken from sys.argv.
        namespace: An object to take the attributes. The default is a new empty Namespace object.

    Returns:
        Dictionary: Parsed command line arguments.
    """
    parser = argparse.ArgumentParser(
        description=__doc__,
        epilog="LeClownWilmah",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("model", choices=["julia", "mandelbrot"],
                        help="Fractal type/model")
    parser.add_argument("c", nargs="*", default=argparse.SUPPRESS,
                        help="Single Julia fractal complex-valued constant "
                             "parameter (needed for julia, shouldn't appear "
                             "for mandelbrot), e.g. -.7102 + .2698j (with the "
                             "spaces), or perhaps with zeros and 'i' like "
                             "-0.6 + 0.4i. If the argument parser gives "
                             "any trouble, just add spaces between the numbers "
                             "and their signals, like '- 0.6 + 0.4 j'")
    parser.add_argument("-s", "--size", default=DEFAULTS['size'],
                        type=pair_reader(int),
                        help="Size in pixels for the output file")
    parser.add_argument("-d", "--depth", default=DEFAULTS['depth'],
                        type=int,
                        help="Iteration depth, the step count limit")
    parser.add_argument("-z", "--zoom", default=DEFAULTS['zoom'],
                        type=float,
                        help="Zoom factor, assuming data is shown in the "
                             "[-1/zoom; 1/zoom] range for both dimensions, "
                             "besides the central point displacement")
    parser.add_argument("-c", "--center", default=DEFAULTS['center'],
                        type=pair_reader(float),
                        help="Central point in the image")
    parser.add_argument("-m", "--cmap", default=DEFAULTS['colormap'],
                        help="Matplotlib colormap name to be used")
    parser.add_argument("-o", "--output", default=argparse.SUPPRESS,
                        help="Output to a file, with the chosen extension, "
                             "e.g. fractal.png")
    parser.add_argument("--show", default=argparse.SUPPRESS,
                        action="store_true",
                        help="Shows the plot in the default Matplotlib backend")

    # Process arguments
    ns_parsed = parser.parse_args(args=args, namespace=namespace)
    if ns_parsed.model == "julia" and "c" not in ns_parsed:
        parser.error("Missing Julia constant")
    if ns_parsed.model == "mandelbrot" and "c" in ns_parsed:
        parser.error("Mandelbrot has no constant")
    if "output" not in ns_parsed and "show" not in ns_parsed:
        parser.error("Nothing to be done (no output file name nor --show)")
    if "c" in ns_parsed:
        try:
            ns_parsed.c = complex("".join(ns_parsed.c).replace("i", "j"))
        except ValueError as exc:
            parser.error(exc)

    return vars(ns_parsed)


if __name__ == "__main__":
  exec_command(cli_parse_args())
